package com.spydermama.api.common.services;

import java.io.Serializable;
import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TimeZone;

import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.transaction.Transactional;
import javax.validation.ConstraintViolation;
import javax.validation.Validator;

import org.apache.commons.beanutils.PropertyUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.builder.DiffBuilder;
import org.apache.commons.lang3.builder.ToStringStyle;
import org.apache.commons.lang3.reflect.FieldUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationEventPublisher;

import com.spydermama.api.base.Actions;
import com.spydermama.api.base.Actions.Crud;
import com.spydermama.api.base.OperationGroups;
import com.spydermama.api.cache.EntityReferenceCache.EntityReferenceCacheEntry;
import com.spydermama.api.common.annotations.AutoGeneratedUUID;
import com.spydermama.api.common.annotations.LifecycleStatus;
import com.spydermama.api.common.annotations.UniqueKey;
import com.spydermama.api.common.auditlog.AuditLog;
import com.spydermama.api.common.auditlog.AuditLogService;
import com.spydermama.api.common.auditlog.Auditable;
import com.spydermama.api.common.auditlog.AuditableChild;
import com.spydermama.api.common.controllers.RestResponse.ErrorResponse;
import com.spydermama.api.common.controllers.RestResponse.ValidationError;
import com.spydermama.api.common.controllers.RestResponseBuilder;
import com.spydermama.api.common.db.EntityManagerProvider;
import com.spydermama.api.common.domain.AbstractResource;
import com.spydermama.api.common.domain.IdentifiableEntity;
import com.spydermama.api.common.domain.AppObect;
import com.spydermama.api.common.events.ResourceChangeEvent;
import com.spydermama.api.common.repos.BaseRepository;
import com.spydermama.api.exception.BadRequestException;
import com.spydermama.api.exception.InvalidRequestException;
import com.spydermama.api.exception.ValidationException;
import com.spydermama.api.exception.ValidationExceptionList;
import com.spydermama.api.utils.BeanUtil;
import com.spydermama.api.utils.CommonUtil;
import com.spydermama.api.utils.EntityUtils;
import com.thetechnovator.common.java.utils.DateUtil;
import com.thetechnovator.common.java.utils.ReflectUtil;

import io.swagger.annotations.ApiModelProperty;
import io.swagger.annotations.ApiModelProperty.AccessMode;

public abstract class BaseCrudService<T extends IdentifiableEntity<ID>, ID extends Serializable> extends BaseEntityService<T, ID> {
	private static final Logger LOG = LoggerFactory.getLogger(BaseCrudService.class);
	protected static final String STATUS_NEW = "N";
	protected static final String COMMA = ",";
	protected static final String STATUS_DEPRECATED = "D";

	@Autowired
	private Validator validator;

	@Autowired
	private AuditLogService auditService;
	@Autowired
	private ApplicationEventPublisher publisher;

	private Field statusField = null;
	private boolean generateKey=false;
	private Map<String, List<Field>> uniqueKeyFields;
	public BaseCrudService(BaseRepository<T, ID> repo, Class<T> entityClass, Class<ID> idClass) {
		super(repo, entityClass, idClass);
		this.repo = repo;
		this.entityClass = entityClass;
		List<Field> fields = FieldUtils.getFieldsListWithAnnotation(entityClass, LifecycleStatus.class);
		if (fields.size() == 1) {
			statusField = fields.get(0);
		} else if (fields.size() > 1) {
			// programming error
			throw new IllegalStateException("Only one field per entity should be set as LifeCycleStatus field");
		}
		fields = FieldUtils.getFieldsListWithAnnotation(entityClass, AutoGeneratedUUID.class);
		if (fields.size() == 1) {
			generateKey=true;
		}
		//get unique key fields
		fields = FieldUtils.getFieldsListWithAnnotation(entityClass, UniqueKey.class);
		if (fields.size() != 0) {
			uniqueKeyFields=new HashMap<>();
			for (Field field: fields) {
				UniqueKey uk = field.getAnnotation(UniqueKey.class);
				List<Field> keyFields = uniqueKeyFields.get(uk.value());
				if (keyFields == null) {
					keyFields = new ArrayList<>();
					uniqueKeyFields.put(uk.value(), keyFields);
				}
				keyFields.add(field);
			}
		}
		
	}

	public List<AuditLog> getHistory(ID id) {
		T obj = getById(id, true);
		if (obj != null) {
			return auditService.find((Auditable<?>) obj, additionalHistory(id));
		} else {
			return auditService.find(getResourceType(), id.toString());
		}
	}

	@Transactional
	public T add(T obj) {
		validate(obj, true);
		return addInternal(obj);
	}

	@Transactional
	public List<ID> addAll(List<T> objList) {
		validate(objList, true);
		List<ID> result = new ArrayList<>();
		for (T obj : objList) {
			T ret = addInternal(obj);
			result.add(ret.getId());
		}

		return result;
	}

	@Transactional
	public void update(ID id, T obj) {
		validate(obj, false);
		updateInternal(id, obj);
	}

	@Transactional
	public void updateAll(List<T> objList) {
		validate(objList, false);
		for (T obj : objList) {
			updateInternal(obj.getId(), obj);
		}
	}

	@Transactional
	public void delete(ID id) {
		deleteInternal(id);
	}

	@Transactional
	public void deleteAllForIds(List<ID> ids) {
		for (ID id : ids) {
			deleteInternal(id);
		}
	}

	@Transactional
	public void deleteAllForObjs(List<T> objList) {
		for (T obj : objList) {
			deleteInternal(obj.getId());
		}
	}

	private void deleteInternal(ID id) {
		T saved = getById(id);
		// check of reference
		ensureNoReferences(saved);
		beforeDelete(saved);
		repo.delete(saved);
		if (saved instanceof Auditable) {
			saveHistory(Actions.Crud.Delete, (Auditable<?>) saved, "Deleted", null);
		} else if (saved instanceof AuditableChild) {
			saveChildHistory(Actions.Crud.Delete, (AuditableChild<?>) saved, "Deleted");
		}
		afterDelete(saved);
		fireResourceChangeEvent(saved, Crud.Delete);
	}

	protected void verifyUniqueId(T obj, ID id) {
		T saved = findById(id);
		if (saved != null) {
			throw new BadRequestException("Functional id '" + obj.getId() + "' is already used");
		}
	}

	protected List<AuditLog> additionalHistory(ID id) {
		return null;
	}

	protected void save(T obj) {
		repo.save(obj);
	}

	protected void beforeSave(T newObj, T oldObj, boolean isAdd) {
		// entity specific login can come here
	}

	protected void afterSave(T newObj, T oldObj, boolean isAdd) {
		// entity specific login can come here
	}

	protected void beforeDelete(T savedObj) {
		// entity specific login can come here
	}

	protected void afterDelete(T savedObj) {
		// entity specific login can come here
	}

	protected void saveHistory(String action, Auditable<?> obj, String details, String prefix) {
		auditService.add(action, obj, details, prefix);
	}

	protected void saveChildHistory(String action, AuditableChild<?> obj, String details) {
		Object parentId = obj.getParentId();
		Object parent = EntityManagerProvider.getEntityManager().find(obj.getParentEntity(), parentId);
		String prefix = obj.getAppObjectType() + " [" + obj.getName() + "]";
		if (action.equals(Actions.Crud.Add)) {
			details = "added";
		}
		auditService.add(Actions.Crud.Update, (Auditable<?>) parent, details, prefix);
	}

	public boolean isEqual(Object compareWith, Object obj) {
		String changes = compareAndCopy(compareWith, obj, false);
		return StringUtils.isEmpty(changes);
	}

	public String compareAndCopy(Object compareWith, Object obj) {
		return compareAndCopy(compareWith, obj, true);
	}

	public String compareAndCopy(Object compareWith, Object obj, boolean copyValue2CompareWith) {
		DiffBuilder<Object> builder = new DiffBuilder<>(compareWith, obj, ToStringStyle.NO_CLASS_NAME_STYLE);

		for (Field field : FieldUtils.getAllFields(obj.getClass())) {
			field.setAccessible(true);
			Object value;
			try {
				value = PropertyUtils.getProperty(obj, field.getName());
				Boolean updateable = value != null;

				if (updateable) {
					updateable = !isFieldReadOnly(field);
				}
				if (updateable) {
					Object oldValue = PropertyUtils.getProperty(compareWith, field.getName());
					if (value instanceof Date) {
						Date dateValue = (Date) value;
						dateValue = adjustTemporalValue(field, dateValue, obj);
						// date is not properly formatted in diff, convert to string
						String newValueStr = null;
						String oldValueStr = null;
						;
						if (value != null) {
							newValueStr = DateUtil.toDateTimeString(dateValue) + " " + TimeZone.getDefault().getID();
						}
						if (oldValue != null) {
							oldValueStr = DateUtil.toDateTimeString((Date) oldValue) + " " + TimeZone.getDefault().getID();
							;
						}
						builder.append(field.getName(), oldValueStr, newValueStr);
					} else {
						builder.append(field.getName(), oldValue, value);
					}
					if (copyValue2CompareWith) {
						PropertyUtils.setProperty(compareWith, field.getName(), value);
					}
				}
			} catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
				throw new IllegalStateException(e);
			}
		}
		String result = builder.build().toString();
		// replace the message
		result = StringUtils.replace(result, "differs from", "changed to");
		return result;
	}

	private void adjustTemporalFields(Object obj) {
		// truncatet the time part for the date only fields
		for (Field field : FieldUtils.getAllFields(obj.getClass())) {
			if (!field.getType().equals(Date.class)) {
				continue;
			}
			field.setAccessible(true);
			Object value;
			try {
				value = PropertyUtils.getProperty(obj, field.getName());
				Date dateValue = (Date) value;
				adjustTemporalValue(field, dateValue, obj);
			} catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
				throw new IllegalStateException(e);
			}
		}

	}

	private Date adjustTemporalValue(Field field, Date value, Object obj) {
		if (value == null) {
			return null;
		}
		Temporal anno = field.getAnnotation(Temporal.class);
		if (anno == null) {
			return value;
		}
		if (anno.value() == TemporalType.DATE) {
			// remove the time part from the date
			Date newValue = DateUtil.toStartOfDay(value);
			try {
				PropertyUtils.setProperty(obj, field.getName(), newValue);
			} catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
				throw new IllegalStateException(e);
			}
			return newValue;
		}
		return value;
	}

	@SuppressWarnings("unchecked")
	private T addInternal(T obj) {
		if (obj instanceof AbstractResource) {
			setAuditData((AbstractResource<ID>) obj, true);
		}
		verifyStatusField(obj);
		adjustTemporalFields(obj);
		ensureUniqueKeys(obj, null, true);
		beforeSave(obj, null, true);
		if (generateKey) {
			obj.setId((ID)CommonUtil.genUUID());
		}
		save(obj);
		afterSave(obj, null, true);
//		if (!(obj instanceof CommonData) && (obj instanceof Auditable)) {
		if (obj instanceof Auditable) {
			// write the audit log, otherwise it is taken from the entity itself
			saveHistory(Actions.Crud.Add, (Auditable<?>) obj, "Added", null);
		} else if (obj instanceof AuditableChild) {
			saveChildHistory(Actions.Crud.Add, (AuditableChild<?>) obj, "Added");
		}
		fireResourceChangeEvent(obj, Crud.Add);
		return obj;
	}

	private void updateInternal(ID id, T obj) {
		if (obj.getId() != null && !obj.getId().equals(id)) {
			throw new BadRequestException("ID field cannot be updated");
		}
		T saved = getById(id);
		ensureUniqueKeys(obj, saved, false);
		beforeSave(obj, saved, false);
		T copy = copy(saved);
		String changes = compareAndCopy(saved, obj);
		if (StringUtils.isEmpty(changes)) {
			LOG.info(String.format("Nothing to update in '%s' for ID '%s'", saved.getClass().getSimpleName(), saved.getId().toString()));
			afterSave(saved, copy, false);
			return;
		}
		if (saved instanceof AbstractResource) {
			setAuditData((AbstractResource<ID>) saved, false);
		}
		save(saved);
		if (saved instanceof Auditable) {
			saveHistory(Actions.Crud.Update, (Auditable<?>) saved, changes, null);
		} else if (obj instanceof AuditableChild) {
			saveChildHistory(Actions.Crud.Update, (AuditableChild<?>) saved, changes);
		}
		afterSave(saved, copy, false);
		fireResourceChangeEvent(saved, Crud.Update);
	}

	private T copy(T obj) {
		try {
			@SuppressWarnings("deprecation")
			T newObj = entityClass.newInstance();
			PropertyUtils.copyProperties(newObj, obj);
			return newObj;
		} catch (InstantiationException | IllegalAccessException e) {
			throw new IllegalStateException(e);
		} catch (InvocationTargetException e) {
			throw new IllegalStateException(e);
		} catch (NoSuchMethodException e) {
			throw new IllegalStateException(e);
		}

	}

	private void validate(T obj, boolean isAdd) {
		Class<?> group = isAdd ? OperationGroups.Add.class : OperationGroups.Update.class;
		Set<? extends ConstraintViolation<?>> errors = validator.validate(obj, group);
		if (!errors.isEmpty()) {
			throw new ValidationException(errors);
		}
	}

	private void validate(List<T> objList, boolean isAdd) {
		Class<?> group = isAdd ? OperationGroups.Add.class : OperationGroups.Update.class;
		List<Set<ConstraintViolation<Object>>> allErrors = new ArrayList<>();
		for (T obj : objList) {
			Set<ConstraintViolation<Object>> errors = validator.validate(obj, group);
			if (!errors.isEmpty()) {
				allErrors.add(errors);
			}
		}

		if (!allErrors.isEmpty()) {
			throw new ValidationExceptionList(allErrors);
		}
	}
	private void ensureUniqueKeys(T newObj, T oldObj, boolean isAdd) {
		if (uniqueKeyFields==null) return;
		for (String key: uniqueKeyFields.keySet()) {
			List<Field> fields = uniqueKeyFields.get(key);
			List<Object> values = BeanUtil.getFieldValue(newObj, fields);
			List<Object> compareValues = new ArrayList<>();
			boolean validate=false;
			if (isAdd) {
				//for add simply check if there are records for the same values
				validate=true;
				compareValues=values;
			}else {
				/*
				 * for update it is complicated. Since there could be multiple fields in a unique key, below points are considered
				 * 1. First check if any of the field in the key has changed.
				 * 2. If any field has changed:
				 *    if the new value is null use the old value, otherwise the new value
				 */
				int i=0;
				List<Object> oldValues = BeanUtil.getFieldValue(oldObj, fields);
				for (Object oldValue: oldValues) {
					Object value = values.get(i);
					compareValues.add(value==null?oldValue:value);
					if (oldValue==null && value != null) {
						validate=true;
					}else if (value != null && !oldValue.equals(value)){
						validate=true;
					}
					i++;
				}
			}
			if (validate) {
				long count = EntityUtils.findRecordCount(entityClass, fields, compareValues);
				if (count > 0) {
					throw new BadRequestException("Values for '"+EntityUtils.getFieldNames(fields)+"' must be unique");
				}
			}
		}
	}

	private void ensureNoReferences(T obj) {
		List<EntityReferenceCacheEntry> refs = staticCache.getEntityReferenceCache().getEntityReferences().get(obj.getClass());
		if (refs == null) {
			return;
		}

		List<ValidationError> errors = new ArrayList<>();
		for (EntityReferenceCacheEntry ref : refs) {
			long refCount = EntityUtils.findRecordCount(ref.getReferencedInEntity(), ref.getReferencedInField(), obj.getId());
			if (refCount != 0) {
				String msg = String.format("%d reference(s) found in '%s'", refCount, ref.getReferencedInEntity().getSimpleName());
				ValidationError error = new ValidationError(null,msg,null);
				errors.add(error);
			}
		}
		if (errors.size() != 0) {
			ErrorResponse resp = RestResponseBuilder.errorResponse(null, null, errors);
			throw new InvalidRequestException(resp);
		}
	}

	private void verifyStatusField(T obj) {
		if (statusField == null) {
			return;
		}

		try {
			Object statusValue = FieldUtils.readField(statusField, obj, true);
			Object newValue = null;
			if (statusField.getType().equals(String.class)) {
				// set status if currently null or empty
				if (statusValue == null || StringUtils.isEmpty(statusValue.toString())) {
					newValue = STATUS_NEW;
				}
			} else if (statusField.getType().equals(Boolean.class)) {
				// boolean status true/false
				if (statusValue == null) {
					newValue = Boolean.FALSE;
				}
			}
			if (newValue != null) {
				FieldUtils.writeField(statusField, obj, newValue, true);
			}
		} catch (IllegalAccessException e) {
			// should not happen. still do not eat the exception
			throw new IllegalStateException(e);
		}

	}

	private boolean isFieldReadOnly(Field field) {
		Annotation annotation = field.getAnnotation(ApiModelProperty.class);
		if (annotation != null) {
			Boolean readOnly = (Boolean) ReflectUtil.getAnnotationFieldValue(annotation, "readOnly");
			if (readOnly) {
				return true;
			}
			String accessMode = ReflectUtil.getAnnotationFieldValue(annotation, "accessMode").toString();
			if (AccessMode.READ_ONLY.name().equals(accessMode)) {
				return true;
			}
		}

		return false;
	}

	protected void fireResourceChangeEvent(T obj, String action) {
		if (!(obj instanceof AppObect)) {
			return;
		}
		AppObect res = (AppObect) obj;
		ResourceChangeEvent<AppObect> event = new ResourceChangeEvent<AppObect>(res, res.getAppObjectType(), action);
		publisher.publishEvent(event);
	}

	public void setAuditData(AbstractResource<ID> obj, boolean isAdd) {
		if (isAdd) {
			obj.setCreateDate(new Date());
			obj.setCreateUser(getLoggedUser());
		}
	}

	protected abstract String getResourceType();
}
